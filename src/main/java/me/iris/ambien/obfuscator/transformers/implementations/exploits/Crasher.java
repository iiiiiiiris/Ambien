package me.iris.ambien.obfuscator.transformers.implementations.exploits;

import me.iris.ambien.obfuscator.Ambien;
import me.iris.ambien.obfuscator.builders.ClassBuilder;
import me.iris.ambien.obfuscator.settings.data.implementations.BooleanSetting;
import me.iris.ambien.obfuscator.settings.data.implementations.ListSetting;
import me.iris.ambien.obfuscator.settings.data.implementations.NumberSetting;
import me.iris.ambien.obfuscator.settings.data.implementations.StringSetting;
import me.iris.ambien.obfuscator.transformers.data.Category;
import me.iris.ambien.obfuscator.transformers.data.Ordinal;
import me.iris.ambien.obfuscator.transformers.data.Stability;
import me.iris.ambien.obfuscator.transformers.data.Transformer;
import me.iris.ambien.obfuscator.transformers.data.annotation.TransformerInfo;
import me.iris.ambien.obfuscator.utilities.IOUtil;
import me.iris.ambien.obfuscator.utilities.StringUtil;
import me.iris.ambien.obfuscator.wrappers.ClassWrapper;
import me.iris.ambien.obfuscator.wrappers.JarWrapper;
import me.iris.ambien.obfuscator.wrappers.MethodWrapper;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;
import java.util.jar.JarOutputStream;
import java.util.stream.Collectors;

/**
 * Crashes & confuses various decompilers & other reverse engineering tools
 */
@TransformerInfo(
        name = "crasher",
        category = Category.EXPLOITS,
        stability = Stability.STABLE,
        ordinal = Ordinal.LOW,
        description = "Adds code/classes that cause decompilers & re tools to fail to decompile the class/jar."
)
public class Crasher extends Transformer {
    private final Map<ClassWrapper, List<MethodWrapper>> classMethodsMap = new ConcurrentHashMap<>();
    private final String repeatType = "[".repeat(255);

    /**
     * Crashes swing based decompilers because of them trying to render the html
     */
    public final BooleanSetting hypertext = new BooleanSetting("hypertext", false);
    public final StringSetting hypertextLink = new StringSetting("hypertext-link", "https://ericsson.cfd/tvoya_mat_prosto");
    public final ListSetting hypertextText = new ListSetting("hypertext-text", new ArrayList<>(List.of("")));

    /**
     * Adds long end-line character annotations to methods & fields
     * This causes decompilers to be very slow or not decompile at all
     */
    public final BooleanSetting badAnnotations = new BooleanSetting("bad-annotations", false);
    public final ListSetting badAnnotationsWords = new ListSetting("bad-annotations-words", new ArrayList<>(List.of("")));
    public final NumberSetting<Integer> badAnnotationsAmount = new NumberSetting<>("bad-annotations-amount", 100);

    /**
     * Adds a class that inherits itself, causing some tools to get stuck in an infinite loop of decompiling the class
     */
    public final BooleanSetting selfInheritance = new BooleanSetting("self-inheritance", false);
    public final StringSetting selfInheritanceName = new StringSetting("self-inheritance-name", "Main");
    public final ListSetting selfInheritanceText = new ListSetting("self-inheritance-text", new ArrayList<>(List.of("")));


    /**
     * Adds random text to null method & class signatures, most decompilers will crash or just ignore it
     */
    public static final BooleanSetting junkSignatures = new BooleanSetting("junk-signatures", false);
    public static final BooleanSetting decompilerCrasher = new BooleanSetting("decompiler-crasher", false);

    public static final BooleanSetting shitClasses = new BooleanSetting("shit-classes", false);
    public static final NumberSetting<Integer> shitAmount = new NumberSetting<>("shit-amount", 100);
    public static final NumberSetting<Integer> shitDepth = new NumberSetting<>("shit-depth", 100);
    public static final NumberSetting<Integer> shitMaxDepth = new NumberSetting<>("shit-max-depth", 500);

    @Override
    public void transform(JarWrapper wrapper) {
        // Add incomplete hypertext
        if (hypertext.isEnabled())
            addSwingCrasherClass(wrapper);

        // Add a class that inherits itself
        if (selfInheritance.isEnabled())
            addSelfInheritanceClass(wrapper);

        if (decompilerCrasher.isEnabled())
            addDecompilerCrasher(wrapper);

        // Add crashers to classes
        getClasses(wrapper).stream()
            .filter(classWrapper -> {
                String className = classWrapper.getNode().name;
                return !(className.contains(hypertextLink.getValue()) || className.contains(selfInheritanceName.getValue()));
            })
            .forEach(classWrapper -> {
                if (badAnnotations.isEnabled()) {
                    List<String> words = new ArrayList<>();
                    badAnnotationsWords.getOptions().forEach(value -> {
                        if (value.endsWith(".txt")) {
                            words.addAll(StringUtil.readDictionaryFromFile(value));
                        } else words.add(value);
                    });
                    addBadAnnotations(classWrapper, words);
                }
                if (junkSignatures.isEnabled())
                    addJunkSignatures(classWrapper);
            }
        );
    }

    private void addDecompilerCrasher(final JarWrapper wrapper) {
        getClasses(wrapper)
                .forEach(classWrapper -> {
                    List<MethodWrapper> methods = classWrapper.getTransformableMethods().stream()
                            // !methodWrapper.hasInstructions() или methodWrapper.hasInstructions()
                            .filter(methodWrapper -> methodWrapper.hasInstructions() && !methodWrapper.isInitializer() && methodWrapper.getNode().instructions.getFirst() instanceof LabelNode)
                            .collect(Collectors.toList());
                    classMethodsMap.put(classWrapper, methods);
                });

        classMethodsMap.forEach((classWrapper, methods) ->
                methods.forEach(methodWrapper -> {
                    MethodNode method = methodWrapper.getNode();
                    InsnList list = new InsnList();
                    list.add(new LabelNode());
                    list.add(new InsnNode(ACONST_NULL));
                    list.add(new JumpInsnNode(IFNULL, (LabelNode) method.instructions.getFirst()));
                    list.add(new InsnNode(ACONST_NULL));
                    list.add(new TypeInsnNode(CHECKCAST,repeatType + "L;"));
                    list.add(new InvokeDynamicInsnNode(StringUtil.randomIllegalJavaName(),"(" + repeatType + "L;)V", new Handle(H_INVOKESTATIC, StringUtil.randomIllegalJavaName(), StringUtil.randomIllegalJavaName(),"()L;",false),""));
                    method.instructions.insertBefore(method.instructions.getFirst(),list);
                })
        );
    }

    public static void addShitClasses(String basePath, JarOutputStream stream) throws IOException {
        ClassNode node = new ClassNode();

        node.name = "<html><img src=\"https:" + StringUtil.randomString(10,"0123456789");
        node.access = ACC_PUBLIC;
        node.version = V1_8;

        ClassWriter writer = new ClassWriter(0);
        node.accept(writer);

        StringBuilder builder = new StringBuilder();

        if (basePath != null) {
            builder.append(basePath);
        }

        for (int i = 0; i < ThreadLocalRandom.current().nextInt(shitDepth.getValue(), shitMaxDepth.getValue()); i++) {
            builder.append("\n\u3000\u2007".charAt(ThreadLocalRandom.current().nextInt(0, 3))).append(File.separator);
        }

        builder.append(StringUtil.randomSpace()).append(".class");
        String s = builder.toString();

        IOUtil.writeEntry(stream, s, writer.toByteArray());
    }

    private void addSwingCrasherClass(final JarWrapper wrapper) {
        final String name = "<html><img src=\"" + hypertextLink.getValue();
        final ClassBuilder builder = new ClassBuilder().setName(name).setAccess(ACC_PUBLIC).setVersion(V1_5);
        final ClassNode node = builder.buildNode();
        if (!hypertextText.getOptions().get(0).equals("")) {
            List<String> inputList = hypertextText.getOptions();
            String[][] messages = new String[inputList.size()][2];

            for (int i = 0; i < inputList.size(); i++) {
                String[] parts = inputList.get(i).split("\\s*\\|\\s*", -1);
                messages[i][0] = parts[0].trim(); // Текст до |
                messages[i][1] = parts[1].trim(); // Текст после |
            }

            for (String[] messageData : messages) {
                FieldNode fieldNode = new FieldNode(ACC_STATIC, messageData[1], "Ljava/lang/String;", null, null);
                node.fields.add(fieldNode);
            }

            MethodNode clinit = new MethodNode(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
            InsnList clinitInstructions = clinit.instructions;

            for (String[] messageData : messages) {
                clinitInstructions.add(new LdcInsnNode(messageData[0]));
                clinitInstructions.add(new FieldInsnNode(Opcodes.PUTSTATIC, name, messageData[1], "Ljava/lang/String;"));
            }

            clinitInstructions.add(new InsnNode(Opcodes.RETURN));
            node.methods.add(clinit);
        }

        wrapper.getClasses().add(new ClassWrapper(name + ".class", node, false));
    }

    private void addSelfInheritanceClass(final JarWrapper wrapper) {
        final String name = selfInheritanceName.getValue();
        final ClassBuilder builder = new ClassBuilder().setName(name).setSuperName(name).setAccess(ACC_PUBLIC);
        final ClassNode node = builder.buildNode();

        if (!selfInheritanceText.getOptions().get(0).equals("")) {
            List<String> inputList = selfInheritanceText.getOptions();
            String[][] messages = new String[inputList.size()][2];

            for (int i = 0; i < inputList.size(); i++) {
                String[] parts = inputList.get(i).split("\\s*\\|\\s*", -1);
                messages[i][0] = parts[0].trim(); // Текст до |
                messages[i][1] = parts[1].trim(); // Текст после |
            }

            for (String[] messageData : messages) {
                FieldNode fieldNode = new FieldNode(ACC_STATIC, messageData[1], "Ljava/lang/String;", null, null);
                node.fields.add(fieldNode);
            }

            MethodNode clinit = new MethodNode(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
            InsnList clinitInstructions = clinit.instructions;

            for (String[] messageData : messages) {
                clinitInstructions.add(new LdcInsnNode(messageData[0]));
                clinitInstructions.add(new FieldInsnNode(Opcodes.PUTSTATIC, name, messageData[1], "Ljava/lang/String;"));
            }

            clinitInstructions.add(new InsnNode(Opcodes.RETURN));
            node.methods.add(clinit);
        }

        wrapper.getClasses().add(new ClassWrapper(name + ".class", node, false));
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    private void addBadAnnotations(final ClassWrapper wrapper, List<String> badAnnotationsWords) {
        // Construct the repeated string with words separated by '\n'
        StringBuilder repeatedEndLineBuilder = new StringBuilder();
        for (int i = 0; i < badAnnotationsAmount.getValue(); i++) {
            repeatedEndLineBuilder.append(badAnnotationsWords.get(i % badAnnotationsWords.size()));
            repeatedEndLineBuilder.append('\n');
        }
        final String repeatedEndLine = repeatedEndLineBuilder.toString();

        // Add invisible annotation to class
        if (wrapper.getNode().invisibleAnnotations == null)
            wrapper.getNode().invisibleAnnotations = new ArrayList();
        wrapper.getNode().invisibleAnnotations.add(new AnnotationNode(repeatedEndLine));

        // Add invisible annotations to methods
        wrapper.getTransformableMethods().forEach(methodWrapper -> {
            final MethodNode methodNode = methodWrapper.getNode();
            if (methodNode.invisibleAnnotations == null)
                methodNode.invisibleAnnotations = new ArrayList();
            methodNode.invisibleAnnotations.add(new AnnotationNode(repeatedEndLine));
        });

        // Add invisible annotations to fields
        wrapper.getFields().forEach(fieldNode -> {
            if (fieldNode.invisibleAnnotations == null)
                fieldNode.invisibleAnnotations = new ArrayList();
            fieldNode.invisibleAnnotations.add(new AnnotationNode(repeatedEndLine));
        });
    }

    private void addJunkSignatures(final ClassWrapper wrapper) {
        // Add junk signature to class
        wrapper.getNode().signature = StringUtil.genName(15);

        // Add junk signature to methods
        wrapper.getTransformableMethods().forEach(methodWrapper -> {
            final MethodNode methodNode = methodWrapper.getNode();
            if (methodNode.signature != null) return;
            methodNode.signature = StringUtil.genName(15);
        });

        // Add junk signature to fields
        wrapper.getFields().forEach(fieldNode -> {
            if (fieldNode.signature != null) return;
            fieldNode.signature = StringUtil.genName(15);
        });
    }
}
